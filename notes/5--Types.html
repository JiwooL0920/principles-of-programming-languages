<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Types</title>
<meta name="author" content="(Mark Armstrong)"/>
<meta name="description" content="Introduction to types"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/dist/theme/black.css" id="theme"/>

<link rel="stylesheet" href="local.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h2 class="title">Types</h2>
   <h3>Principles of Programming Languages</h3>
   <h4>Mark Armstrong</h4>
   <h5>Fall 2020</h5>
</section>

<section>
<section id="slide-orgf8897d5">
<h2 id="orgf8897d5"><span class="section-number-2">1</span> Preamble</h2>
<div class="outline-text-2" id="text-1">
</div>
</section>
<section id="slide-org6a28605">
<h3 id="org6a28605"><span class="section-number-3">1.1</span> Notable references</h3>
<ul>
<li>Robert W. Sebesta, “Concepts of Programming Languages” (10th edition)
<ul>
<li>Chapter 6, Data Types</li>

</ul></li>

<li>Benjamin Pierce,
“<a href="https://ebookcentral.proquest.com/lib/mcmu/detail.action?docID=3338823">Types and Programming Languages</a>”
<ul>
<li>Chapter 11, Simple Extensions
<ul>
<li>Unit, Tuples, Sums, Variants, Lists.</li>

</ul></li>
<li>Chapter 13, References
<ul>
<li>Reference types.</li>

</ul></li>
<li>Chapter 20, Recursive types</li>

</ul></li>

</ul>

</section>
<section id="slide-org488e009">
<h3 id="org488e009"><span class="section-number-3">1.2</span> <span class="todo TODO">TODO</span> Table of contents</h3>
<font size="-1">
<div class="scriptsize" id="org81fafc6">
<ul>
<li><a href="#/slide-orgf8897d5">Preamble</a></li>

</ul>

</div>
</font>

</section>
</section>
<section>
<section id="slide-org8ff89db">
<h2 id="org8ff89db"><span class="section-number-2">2</span> Introduction</h2>
<p>
This section introduces the concepts of <i>types</i>,
a particularly useful language safety feature.
</p>

<p>
Common simple types and methods of building new types are discussed,
as well as some more advanced topics.
</p>

<p>
The discussion in this section is fairly “encyclopedic”;
the next section on the typed λ-calculus give some insight about
how some of these types can be incorporated into a programming system.
</p>

</section>
</section>
<section>
<section id="slide-org3771049">
<h2 id="org3771049"><span class="section-number-2">3</span> Properties of type systems</h2>
<p>
In the previous notes, we have discussed
</p>
<ul>
<li>polymorphism and</li>
<li>static/dynamic typing</li>

</ul>
<p>
which are two important properties of a type system.
</p>

<p>
Here we discuss some other commonly discussed properties,
before discussing in the following sections
what is arguably the most important property:
what types a language might have.
</p>

</section>
<section id="slide-orgeed8063">
<h3 id="orgeed8063"><span class="section-number-3">3.1</span> “Strong” and “weak” typing</h3>
<p>
These are comparative terms.
</p>
<ul>
<li>We'll consider them a subjective criteria.</li>

</ul>

<p>
“Strongly typed”
</p>
<ul>
<li>Languages are frequently called strongly typed.
<ul>
<li>But less frequently do they state what they mean by that.</li>
<li>The term is used inconsistently.
<ul>
<li>“C is a strongly typed, weakly checked language”
– Dennis Ritchie, creator of C</li>

</ul></li>

</ul></li>

</ul>

<p>
“Weakly typed” simply means not strongly typed.
</p>

</section>
<section id="slide-org8cd6567">
<h4 id="org8cd6567"><span class="section-number-4">3.1.1</span> So what does “strongly typed” mean?</h4>
<p>
We will take it to mean “type clashes are restricted”.
</p>
<ul>
<li>A <i>type clash</i> being an instance where one type is expected
but a different, incompatible type is provided.
<ul>
<li>Such as added a string to an integer.</li>

</ul></li>
<li>That definition does not make a good objective property.
<ul>
<li>What does restricted mean?
<ul>
<li>Is it a warning or an error?</li>
<li>Does type casting violate this?</li>

</ul></li>
<li>What qualifies as a type clash?
<ul>
<li>Is implicit type casting allowed?</li>

</ul></li>

</ul></li>

</ul>

</section>
<section id="slide-org414827d">
<h4 id="org414827d"><span class="section-number-4">3.1.2</span> Exercise: Examples of implicit type casting</h4>
<p>
What are the results of these two Javascript output statements?
</p>
<div class="org-src-container">

<pre  class="src src-js"><code trim>console.log<span style="color: #00cd68;">(</span>1 + 2 + <span style="color: #79a8ff;">"3"</span><span style="color: #00cd68;">)</span>
console.log<span style="color: #00cd68;">(</span><span style="color: #79a8ff;">"1"</span> + 2 + 3<span style="color: #00cd68;">)</span>
</code></pre>
</div>

<p>
How about the following C++ code?
(This is arguably not quite an example of implicit type casting.)
</p>
<div class="org-src-container">

<pre  class="src src-C++"><code trim><span style="color: #ff9977;">#include</span><span style="color: #00cd68;">&lt;</span><span style="color: #79a8ff;">iostream</span><span style="color: #00cd68;">&gt;</span>

<span style="color: #f78fe7;">int</span> <span style="color: #feacd0;">main</span><span style="color: #00cd68;">()</span> <span style="color: #00cd68;">{</span>
  <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #b6a0ff;">(</span><span style="color: #79a8ff;">"Hello"</span> + 1<span style="color: #b6a0ff;">)</span>;
<span style="color: #00cd68;">}</span>
</code></pre>
</div>

</section>
<section id="slide-org37b3994">
<h3 id="org37b3994"><span class="section-number-3">3.2</span> Explicit and implicit typing</h3>
<p>
Languages may require annotations on variables and functions
(<i>explicit typing</i>) or allow them to be omitted (<i>implicit typing</i>).
</p>
<ul>
<li>Implicit typing does not weaken the typing system in any way!
<ul>
<li>A very common misconception.</li>

</ul></li>
<li>In general, type inference is an undecidable problem
(its not guaranteed that the compiler/interpreter can
determine the type).
<ul>
<li>Most languages have relatively simple type systems,
and this is not a problem.</li>
<li>We will likely later study the <i>Hindley-Milner</i> type system
for the λ-calculus, which is used for many
functional languages and supports parametric polymorphism.</li>

</ul></li>

</ul>

</section>
<section id="slide-orgd8804b2">
<h4 id="orgd8804b2"><span class="section-number-4">3.2.1</span> Implicit typing by name</h4>
<p>
Some languages make type annotations a part of the name,
or annotate names with sigils to indicate type details.
</p>
<ul>
<li>In older versions of Fortran, names beginning with
<code>i</code>, <code>j</code> or <code>k</code> were for integer variables,
and all variables were of floating point.</li>
<li>In Perl, names beginning with the sigil
<ul>
<li><code>$</code> have scalar type,</li>
<li><code>@</code> have array type,</li>
<li><code>%</code> have hash type, and</li>
<li><code>&amp;</code> have subroutine type.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org1da9390">
<h2 id="org1da9390"><span class="section-number-2">4</span> Atomic types</h2>
<p>
We begin our discussion of what types languages have
with what are usually the “simplest” types: <i>atomic</i> types.
</p>
<ul>
<li>Atomic in the sense that they cannot be broken down any further.</li>
<li>Sometimes called <i>primitive</i> or <i>basic</i>.</li>

</ul>

</section>
<section id="slide-orgf0ad614">
<h3 id="orgf0ad614"><span class="section-number-3">4.1</span> Ubiquitous basic types</h3>
<p>
Most languages have at least these atomic types.
</p>
<ul>
<li><b>Integers</b>; <code>int</code>
<ul>
<li>Including possibly signed, unsigned, short, and/or long variants.</li>

</ul></li>
<li><b>Floating point</b> numbers
<ul>
<li>Including possibly single precision and double precision variants.</li>

</ul></li>
<li><b>Characters</b>
<ul>
<li>Sometimes an alternate name for the byte type (8-bit integers).</li>

</ul></li>
<li><b>Booleans</b>
<ul>
<li>Which, of course, can be stored in a bit,
but will usually be stored in at least a word (4 bits)
or perhaps even a byte (8 bits)
for convenience of memory access.</li>

</ul></li>

</ul>

</section>
<section id="slide-orgeebc312">
<h3 id="orgeebc312"><span class="section-number-3">4.2</span> Singleton and empty types</h3>
<ul>
<li><b>Unit</b> (the <i>singleton</i> type)
<ul>
<li>Sometimes called <code>void</code>, <code>nil</code>-type, <code>null</code>-type or <code>none</code>-type.
<ul>
<li>In C-like languages, you cannot store something of type <code>void</code>.
<ul>
<li>But this value still implicitely exists;
a function of type <code>void</code> can certainly
return, implying it returns something of type <code>void</code>.</li>

</ul></li>
<li>Commonly represented as the type of 0-ary tuples,
whose only element is <code>()</code>.</li>

</ul></li>

</ul></li>
<li><b>Empty</b>
<ul>
<li>Unlike a singleton type, which has a single value
(called <code>nil</code>, <code>null</code> or <code>none</code>), there is
(or should be) <b>nothing</b> in the empty type.
<ul>
<li>This might be violated by using error values.</li>
<li>For instance, in Haskell, the term referred to as <code>bottom</code> or ⊥
—which refers to any computation which never completes—
 is a member of all types, even the empty type.</li>

</ul></li>
<li>No function with return type <code>Empty</code> should
ever be able return.</li>

</ul></li>

</ul>

</section>
<section id="slide-org1ed4bcf">
<h4 id="org1ed4bcf"><span class="section-number-4">4.2.1</span> Singleton and empty types in Haskell</h4>
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #b6a0ff;">data</span> <span style="color: #f78fe7;">Unit</span> <span style="color: #00d3d0;">=</span> <span style="color: #f78fe7;">Unit</span> <span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">This type Unit has a single constructor, also called Unit.</span>
<span style="color: #b6a0ff;">data</span> <span style="color: #f78fe7;">Empty</span> <span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">Empty has no constructors.</span>

<span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">Previous versions of Haskell required a workaround to write Empty,</span>
<span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">as a constructor list was mandatory;</span>
<span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">this alternate definition has a constructor also called EmptyAlt,</span>
<span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">but using this constructor requires an argument of type EmptyAlt</span>
<span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">to already exist, so should never actually be usable.</span>
<span style="color: #b6a0ff;">data</span> <span style="color: #f78fe7;">EmptyAlt</span> <span style="color: #00d3d0;">=</span> <span style="color: #f78fe7;">EmptyAlt</span> <span style="color: #f78fe7;">EmptyAlt</span>


<span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">The bottom can be defined by unending recursion.</span>
<span style="color: #feacd0;">bottom</span> <span style="color: #00d3d0;">=</span> bottom
  
<span style="color: #feacd0;">x</span> <span style="color: #00d3d0;">=</span> <span style="color: #f78fe7;">Unit</span>

<span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">We can cheat and get Empty/EmptyAlt "values" by using bottom.</span>
<span style="color: #feacd0;">y</span> <span style="color: #00d3d0;">=</span> bottom <span style="color: #00d3d0;">::</span> <span style="color: #f78fe7;">Empty</span>
<span style="color: #feacd0;">z</span> <span style="color: #00d3d0;">=</span> bottom <span style="color: #00d3d0;">::</span> <span style="color: #f78fe7;">EmptyAlt</span>

<span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">Check the types of these values</span>
<span style="color: #f78fe7;">:</span>t x   <span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">reports x :: Unit</span>
<span style="color: #f78fe7;">:</span>t y   <span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">reports y :: Empty</span>
<span style="color: #f78fe7;">:</span>t z   <span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">reports z :: EmptyAlt</span>
</code></pre>
</div>
<p>
Use the scroll bar to see the full example.
</p>

</section>
<section id="slide-org18310c4">
<h3 id="org18310c4"><span class="section-number-3">4.3</span> Implementation of atomic types</h3>
<p>
When we discussed the pure untyped λ-calculus,
we discussed the process of <i>encoding</i> the integers and booleans
as functions, since they were not included in the language.
</p>
<ul>
<li>We also mentioned that we can add constants for them
to the language, forming an <i>unpure</i> untyped λ-calculus.</li>

</ul>

<p>
This raises a question we can ask about
“practical” programming languages as well;
</p>
<ul>
<li>are the “atomic” (“primitive”, “basic”) types <i>truly</i> atomic
(primitive, basic), or are they represented
using one of the language's abstractions?</li>
<li>We have discussed the fact that in Scala and Ruby, which we call
“purely object-oriented”, even these atomic types are classes!
<ul>
<li>Whereas in Java and C++, they are not;
there, they are “primitives” which exist
outside the object-oriented abstraction.</li>

</ul></li>

</ul>

</section>
<section id="slide-orgcb905d6">
<h3 id="orgcb905d6"><span class="section-number-3">4.4</span> Atom or symbol types</h3>
<p>
Many languages include a type of <i>atoms</i> or <i>symbols</i>,
which are essentially interned strings.
</p>
<ul>
<li>Strings which are immutable,
and of which there is only one copy in memory.</li>

</ul>

<p>
Specifically, decendents of Lisp and Prolog tend to have a symbol type.
</p>

<p>
For instance, in Ruby:
</p>
<div class="org-src-container">

<pre  class="src src-ruby"><code trim><span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">A symbol in Ruby begins with a :</span>
x = <span style="color: #00bcff;">:hello</span>

<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">We can intern strings using an intern method</span>
y = <span style="color: #79a8ff;">"hello"</span>.intern

<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">The equal? method checks if two values are the same object.</span>
<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">These all evaluate to true, since there's only one copy of the symbol hello.</span>
<span style="color: #f78fe7;">puts</span> x.equal?<span style="color: #00cd68;">(</span>y<span style="color: #00cd68;">)</span>
<span style="color: #f78fe7;">puts</span> <span style="color: #00bcff;">:hello</span>.equal?<span style="color: #00cd68;">(</span>x<span style="color: #00cd68;">)</span>
<span style="color: #f78fe7;">puts</span> y.equal?<span style="color: #00cd68;">(</span><span style="color: #00bcff;">:hello</span><span style="color: #00cd68;">)</span>

<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">But this to false, because these are two copies of the same string!</span>
<span style="color: #f78fe7;">puts</span> <span style="color: #79a8ff;">"hello"</span>.equal?<span style="color: #00cd68;">(</span><span style="color: #79a8ff;">"hello"</span><span style="color: #00cd68;">)</span>
</code></pre>
</div>

</section>
<section id="slide-org80ac613">
<h3 id="org80ac613"><span class="section-number-3">4.5</span> Ordinal types</h3>
<p>
Many languages include a means of defining other <i>finite</i> types.
Instances include
</p>
<ul>
<li>enumeration types (<code>enum</code>'s) and</li>
<li>subset/subrange types.</li>

</ul>

<p>
For instance, Pascal supports both enumerations
and subranges.
(This example based on one from the <a href="https://wiki.freepascal.org/Data_type">Free Pascal and Lazarus Wiki</a>.)
</p>
<div class="org-src-container">

<pre  class="src src-pascal"><code trim><span style="color: #f78fe7;">type</span>
  <span style="color: #a8a8a8;">// An enumeration type; unless specified,</span>
  <span style="color: #a8a8a8;">// the first element is implicitely assigned the ordinal value 0,</span>
  <span style="color: #a8a8a8;">// the second ordinal value 1, etc.</span>
  DaysOfWeek = <span style="color: #00cd68;">(</span>Sunday, Monday, Tuesday, Wednesday,
                Thursday, Friday, Saturday<span style="color: #00cd68;">)</span>;

  <span style="color: #a8a8a8;">// A subrange type.</span>
  <span style="color: #a8a8a8;">// In this case, DaysOfWorkWeek contains the ordinals 1,2,3,4 and 5.</span>
  DaysOfWorkWeek = Monday..Friday;
</code></pre>
</div>

</section>
<section id="slide-orgb799b80">
<h3 id="orgb799b80"><span class="section-number-3">4.6</span> Less common numeric types</h3>
<ul>
<li><b>Complex</b> numbers
<ul>
<li>Especially for scientific computation.</li>

</ul></li>
<li><b>Decimal</b> (representation of) numbers
<ul>
<li>Especially for business (monetary) applications.</li>
<li>There are decimal numbers that cannot be properly represented
using binary (e.g. <code>0.3 = 0.010011</code>, repeating)</li>
<li>Not included in all languages because
they cannot be efficiently represented.
<ul>
<li>For instance, to store a decimal digit directly
(without conversion to binary) takes at least 4 bits.</li>
<li>There are 10 possibilities, too many for 3 bits (which can
only have 8 different states.)</li>
<li>But 4 bits could represent 16 states (6 more than needed.)</li>
<li>For memory access reasons, some such implementations
even use 8 bits (one byte) per decimal digit.</li>

</ul></li>

</ul></li>

</ul>

</section>
<section id="slide-orgc3e1a5c">
<h4 id="orgc3e1a5c"><span class="section-number-4">4.6.1</span> Complex numbers in C#</h4>
<p>
(This example code taken from the
<a href="https://docs.microsoft.com/en-us/dotnet/api/system.numerics.complex?view=netcore-3.1">.NET documentation</a>.)
</p>
<div class="org-src-container">

<pre  class="src src-csh"><code trim>using System;
using System.Numerics;

public class Example
{
   public static void Main()
   {
      // Create a complex number by calling its class constructor.
      Complex c1 = new Complex(12, 6);
      Console.WriteLine(c1);

      // Assign a Double to a complex number.
      Complex c2 = 3.14;
      Console.WriteLine(c2);

      // Cast a Decimal to a complex number.
      Complex c3 = (Complex) 12.3m;
      Console.WriteLine(c3);

      // Assign the return value of a method to a Complex variable.
      Complex c4 = Complex.Pow(Complex.One, -1);
      Console.WriteLine(c4);

      // Assign the value returned by an operator to a Complex variable.
      Complex c5 = Complex.One + Complex.One;
      Console.WriteLine(c5);

      // Instantiate a complex number from its polar coordinates.
      Complex c6 = Complex.FromPolarCoordinates(10, .524);
      Console.WriteLine(c6);
   }
}
// The example displays the following output:
//       (12, 6)
//       (3.14, 0)
//       (12.3, 0)
//       (1, 0)
//       (2, 0)
//       (8.65824721882145, 5.00347430269914)
</code></pre>
</div>
<p>
 Use the scroll bar to see the full example.
</p>

</section>
<section id="slide-org41ec6e3">
<h4 id="org41ec6e3"><span class="section-number-4">4.6.2</span> Decimal numbers in C#</h4>
<p>
(This example code taken from the
<a href="https://docs.microsoft.com/en-us/dotnet/api/system.decimal?view=netcore-3.1">.NET documentation</a>.)
</p>
<div class="org-src-container">

<pre  class="src src-csh"><code trim>// Keeping my fortune in Decimals to avoid the round-off errors.
class PiggyBank {
    protected decimal MyFortune;

    public void AddPenny() {
        MyFortune = Decimal.Add(MyFortune, .01m);
    }

    public decimal Capacity {
        get {
            return Decimal.MaxValue;
        }
    }

    public decimal Dollars {
        get {
            return Decimal.Floor(MyFortune);
        }
    }

    public decimal Cents {
        get {
            return Decimal.Subtract(MyFortune, Decimal.Floor(MyFortune));
        }
    }

    public override string ToString() {
        return MyFortune.ToString("C")+" in piggy bank";
    }
}
</code></pre>
</div>
<p>
 Use the scroll bar to see the full example.
</p>

</section>
</section>
<section>
<section id="slide-org70c3254">
<h2 id="org70c3254"><span class="section-number-2">5</span> Structured data</h2>
<p>
Of course, we rarely want to deal only with “atomic” data.
More commonly, we are interested in <i>collections</i> of data,
or <i>alternatives</i> between different data types;
these are captured in the notion of <i>structured</i> data.
</p>

<p>
Specifically, we consider
</p>
<ul>
<li>products,</li>
<li>sequences,
<ul>
<li>including arrays and lists</li>

</ul></li>
<li>“sets”
<ul>
<li>(really associative arrays (maps/hashes/tables))</li>

</ul></li>
<li>and unions/variants.</li>

</ul>

</section>
<section id="slide-orgc35d009">
<h3 id="orgc35d009"><span class="section-number-3">5.1</span> Homogeneous or heterogeneous</h3>
<p>
An important design decision for any structured type
is whether it is <i>homogeneous</i> or <i>heterogeneous</i>.
</p>
<ul>
<li>“Heterogeneous” structures store elements of differing types.</li>
<li>“Homogeneous” store only elements of the same type.</li>

</ul>

</section>
<section id="slide-orgd28727a">
<h3 id="orgd28727a"><span class="section-number-3">5.2</span> Product types (tuples)</h3>
<p>
A <i>heterogeneous</i> collection of a <i>fixed</i> number of elements.
</p>
<ul>
<li>Implemented by, for instance,
<ul>
<li><code>struct</code>'s or records,
<ul>
<li>both of which have labelled fields,</li>

</ul></li>
<li>tuples,
<ul>
<li>which are often be implemented as records with
specially named fields, such as “<code>first</code>” or “<code>_1</code>”, and</li>

</ul></li>
<li>classes,
<ul>
<li>which have <i>methods</i> as well as fields.</li>

</ul></li>

</ul></li>
<li>In lower level languages, programmers may be concerned
with the alignment/packing of the data.
<ul>
<li>See <a href="http://www.catb.org/esr/structure-packing/">this overview</a> of structure packing in C,
and the sort of memory inefficiency that can result
from poorly ordering the fields of a <code>struct</code>.</li>

</ul></li>

</ul>

</section>
<section id="slide-org446edf1">
<h3 id="org446edf1"><span class="section-number-3">5.3</span> Array types</h3>
<p>
Arrays are an abstraction of finite sequences of
adjacent memory cells.
</p>
<ul>
<li>Programmers are guaranteed (or required to work around) certain properties.
<ul>
<li><code>O(1)</code> access/update time for any element.
<ul>
<li>Implying elements are stored in adjacent memory cells
(a <i>contiguous block</i> of memory cells.)</li>
<li>Also implying each element is of a known, usually constant, size.
<ul>
<li>Heterogeneous arrays can store <i>references</i> to elements of differing types
instead of elements of those types themselve to maintain this property.</li>

</ul></li>
<li>To perform a lookup, just look <code>element_space * index</code> bits
past the start of the array.</li>

</ul></li>
<li><code>O(n)</code> insert time (if inserting is possible.)
<ul>
<li>The (possibly <code>n</code>-many) elements after the insertion point
must be shifted.</li>

</ul></li>
<li>It may be computationally costly or impossible to modify length.</li>

</ul></li>

</ul>

<p>
We can classify arrays by where and how their memory is allocated.
</p>

</section>
<section id="slide-org02a4a0d">
<h3 id="org02a4a0d"><span class="section-number-3">5.4</span> Classification of arrays based on memory allocation: data segment and stack</h3>
<ul>
<li>Static arrays
<ul>
<li>(Memory) allocation is static, and presumably in the data segment.</li>
<li>Subscript ranges are statically bound.</li>

</ul></li>
<li>Fixed stack-dynamic arrays
<ul>
<li>Allocation is dynamic and on the stack,
done when the declaration of the array is reached.</li>
<li>Subscript ranges are statically bound.</li>

</ul></li>
<li>Stack-dynamic arrays
<ul>
<li>Allocation is dynamic and on the stack,
done when the declaration of the array is reached.</li>
<li>Subscript ranges are dynamically bound when the declaration is reached.</li>
<li>After declaration, subscript range and storage remain fixed.</li>

</ul></li>

</ul>

</section>
<section id="slide-orgf552918">
<h3 id="orgf552918"><span class="section-number-3">5.5</span> Classification of arrays based on memory allocation: heap</h3>
<ul>
<li>Fixed heap-dynamic arrays
<ul>
<li>Allocation is dynamic, done when the user program requests.</li>
<li>Subscript ranges are dynamically bound at allocation time.
After allocation, subscript range and storage remain fixed.</li>

</ul></li>
<li>Heap-dynamic arrays
<ul>
<li>Allocation is dynamic, done when the user program requests.</li>
<li>Subscript ranges are dynamically bound at allocation time.</li>
<li>Subscript range and storage can change throughout runtime!</li>
<li>These are commonly implemented as <i>array-lists</i>, discussed shortly.</li>

</ul></li>

</ul>

</section>
<section id="slide-orgbccd9dc">
<h3 id="orgbccd9dc"><span class="section-number-3">5.6</span> List types</h3>
<p>
Lists are simply an abstract notion of sequences.
</p>
<ul>
<li>May be implemented by arrays or by structures such as linked lists.</li>
<li>Often we do not <code>O(1)</code> access time for lists.</li>
<li>But we do have better flexibility;
<ul>
<li>appending or prepending an element into a linked list
only requires changing a pointer,</li>
<li>and inserting into a list only requires changing <code>O(n)</code> pointers.</li>

</ul></li>

</ul>

<p>
Persistance of data is more feasible using linked lists;
parts of the list can be reused.
</p>
<ul>
<li>For instance, two immutable lists <code>[1,2,3,4]</code> <code>[5,6,3,4]</code> can share
the storage for the <code>3</code> and <code>4</code> elements.</li>

</ul>

<p>
Lazily (non-strictly) constructed lists may even be “infinite”.
For instance, the infinite list of 1's in Haskell:
</p>
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #feacd0;">ones</span> <span style="color: #00d3d0;">=</span> 1 <span style="color: #00d3d0;">::</span> ones
</code></pre>
</div>

</section>
<section id="slide-org6ad1e23">
<h3 id="org6ad1e23"><span class="section-number-3">5.7</span> Array lists</h3>
<p>
An <i>array list</i> type provides the flexibility of a list,
but the performance of an array (except for the occasional reallocation.)
</p>
<ul>
<li>Array lists are stored in a continguous block of memory cells.</li>
<li>And the block is just reallocated when the array grows too large.
<ul>
<li>Reallocating memory is costly,
and it requires copying the elements to the new memory,
and so there is a performance dip when this is needed.</li>
<li>Generally, <i>twice as much</i> memory as is needed is allocated.
<ul>
<li>So as the size of the list grows, so does the extra memory allocated
at each reallocation.</li>
<li>This mitigates the cost of reallocation; it becomes less frequent
as time goes on.</li>

</ul></li>

</ul></li>

</ul>

</section>
<section id="slide-org4403c55">
<h3 id="org4403c55"><span class="section-number-3">5.8</span> “Sets”</h3>
<p>
It is notoriously difficult to represent unordered collections
such as sets and bags on computers.
</p>
<ul>
<li>Computers are extremely ordered machines; how do we store
unordered collections in ordered memory?</li>
<li>When available, “set types” are usually implemented
using <i>trees</i> or <i>associative arrays</i> (discussed next.)</li>

</ul>

</section>
<section id="slide-org7dbc053">
<h3 id="org7dbc053"><span class="section-number-3">5.9</span> Associative array (map, hash, table) types</h3>
<p>
Associative arrays, also called <i>hashes</i>, <i>maps</i> or sometimes <i>tables</i>,
are sets of key/value pairs.
</p>
<ul>
<li>Abstracts away the ordering of the sequence.
<ul>
<li>(Though we could order the keys, and so impose
an order on the collection.)</li>

</ul></li>
<li>The programmer can imagine they are lists of key/value pairs.
<ul>
<li>And they may even be implemented that way.
<ul>
<li>But in practical languages, they are more often
implemented by sorting elements into “buckets”
by a hashing function on the keys.</li>
<li>The implementations get quite complex.</li>

</ul></li>

</ul></li>

</ul>

</section>
<section id="slide-orgf04eee9">
<h3 id="orgf04eee9"><span class="section-number-3">5.10</span> Unions, variants</h3>
<p>
Whereas an element of a product type contains
</p>
<ul>
<li>a collection of elements of some types,</li>

</ul>
<p>
a <i>union</i> or variant type contains
</p>
<ul>
<li>one element of a selection of types.</li>

</ul>

<p>
Unions can be <i>tagged</i> or <i>untagged</i>.
</p>
<ul>
<li>With an untagged union, the runtime does not
keep track of the underlying type of the element.</li>
<li>Whereas a tagged union uses a <i>tag</i> on the value to identify
the underlying type of the element.</li>

</ul>

<p>
Note that union types are unnecessary
in dynamically type checked language.
</p>
<ul>
<li>We can think of every variable/argument/procedure's type
as being a union of all possible types.</li>

</ul>

</section>
<section id="slide-org55cf72c">
<h3 id="org55cf72c"><span class="section-number-3">5.11</span> Untagged unions</h3>
<p>
As we've said, with an untagged union,
the runtime does not keep track of the underlying type of elements.
</p>
<ul>
<li>So it's type is dynamic! (Amongst the types involved in the union.)</li>
<li>Languages that provide untagged unions (today, mainly C and C++)
do not even dynamically check the type.</li>
<li>Accessing it as the wrong type simply treats the bits
as if they were of that type; it is not a cast!</li>
<li>This is <i>very</i> unsafe; it allows for type clashes.</li>

</ul>

</section>
<section id="slide-org817cc61">
<h4 id="org817cc61"><span class="section-number-4">5.11.1</span> An example usage of untagged unions in C++</h4>
<p>
We can see the danger of untagged unions in a short C++ example;
we are legally allowed to interpret the bits of an integer
as if they were the bits of a floating point,
which has a very different arrangement in memory!
</p>
<div class="org-src-container">

<pre  class="src src-C++"><code trim><span style="color: #ff9977;">#include</span><span style="color: #00cd68;">&lt;</span><span style="color: #79a8ff;">iostream</span><span style="color: #00cd68;">&gt;</span>

<span style="color: #b6a0ff;">union</span> <span style="color: #f78fe7;">foo</span> <span style="color: #00cd68;">{</span>
  <span style="color: #f78fe7;">int</span> <span style="color: #00d3d0;">a</span>;
  <span style="color: #f78fe7;">float</span> <span style="color: #00d3d0;">b</span>;
<span style="color: #00cd68;">}</span>;

<span style="color: #f78fe7;">int</span> <span style="color: #feacd0;">main</span><span style="color: #00cd68;">()</span> <span style="color: #00cd68;">{</span>
  <span style="color: #f78fe7;">foo</span> <span style="color: #00d3d0;">x</span>;

  x.a = 1; <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Set x as an integer.</span>
  
  <span style="color: #00bcff;">std</span>::cout &lt;&lt; x.b; <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Treat x as a float, even though it's an int right now.</span>
                    <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">The typechecker does not complain!</span>
  
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Outputs 1.4013e-45 during my testing;</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">the result of interpreting the bits of x as a float.</span>
<span style="color: #00cd68;">}</span>
</code></pre>
</div>

<p>
For a more practical usage of untagged unions, see the example
implementation of a language of integer expressions in C++,
provided in homework 6.
</p>

</section>
<section id="slide-orgcc94980">
<h3 id="orgcc94980"><span class="section-number-3">5.12</span> Tagged unions and pattern matching</h3>
<p>
Tagged unions are also known as
</p>
<ul>
<li><i>sum</i> and <i>either</i> types, or</li>
<li>as <i>variant</i> types when the labels are chosen by the programmer.</li>

</ul>

<p>
The introduction of tags or labels makes <i>pattern matching</i> a viable
and useful control structure.
</p>

<p>
Given a variant type such as
</p>
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #b6a0ff;">data</span> <span style="color: #f78fe7;">Foo</span> <span style="color: #00d3d0;">=</span> <span style="color: #f78fe7;">A</span> <span style="color: #f78fe7;">Int</span> <span style="color: #00d3d0;">|</span> <span style="color: #f78fe7;">B</span> <span style="color: #f78fe7;">Float</span>
</code></pre>
</div>

<p>
We can <i>match</i> on the tag, using placeholder variables
for the values of the underlying types.
</p>
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #feacd0;">bar</span> <span style="color: #00d3d0;">::</span> <span style="color: #f78fe7;">Foo</span> <span style="color: #00d3d0;">-&gt;</span> <span style="color: #f78fe7;">Int</span>
<span style="color: #feacd0;">bar</span> <span style="color: #00cd68;">(</span><span style="color: #f78fe7;">A</span> i<span style="color: #00cd68;">)</span> <span style="color: #00d3d0;">=</span> i   <span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">i is a placeholder for the integer value.</span>
<span style="color: #feacd0;">bar</span> <span style="color: #00cd68;">(</span><span style="color: #f78fe7;">B</span> <span style="color: #b6a0ff;">_</span><span style="color: #00cd68;">)</span> <span style="color: #00d3d0;">=</span> 0   <span style="color: #a8a8a8;">-- </span><span style="color: #a8a8a8;">An example of a nameless placeholder, _.</span>
</code></pre>
</div>
<p>
Many languages also allow the use of constants
instead of placeholder variables, to create more specific cases.
</p>

</section>
<section id="slide-orgb1e667e">
<h3 id="orgb1e667e"><span class="section-number-3">5.13</span> Recursive unions</h3>
<p>
If a union type is allowed to be <i>recursive</i> (meaning that
one of the underlying types of the union is allowed to be
the type being defined as the union),
then union and product types together allow for the definition
of <i>algebraic datatypes</i> (discussed later.)
</p>

<p>
A well-known example is to define lists as a recursive union
of products.
</p>
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #b6a0ff;">data</span> <span style="color: #f78fe7;">List</span> <span style="color: #00d3d0;">=</span> <span style="color: #f78fe7;">Cons</span> <span style="color: #00cd68;">(</span><span style="color: #f78fe7;">Int</span>, <span style="color: #f78fe7;">List</span><span style="color: #00cd68;">)</span> <span style="color: #00d3d0;">|</span> <span style="color: #f78fe7;">Empty</span>
</code></pre>
</div>

<p>
(Using a type parameter and currying, we get this more flexible
definition more in the style of most functional languages.)
</p>
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #b6a0ff;">data</span> <span style="color: #f78fe7;">List</span> <span style="color: #f78fe7;">A</span> <span style="color: #00d3d0;">=</span> <span style="color: #f78fe7;">Cons</span> <span style="color: #f78fe7;">A</span> <span style="color: #00cd68;">(</span><span style="color: #f78fe7;">List</span> <span style="color: #f78fe7;">A</span><span style="color: #00cd68;">)</span> <span style="color: #00d3d0;">|</span> <span style="color: #f78fe7;">Empty</span>
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org6b47220">
<h2 id="org6b47220"><span class="section-number-2">6</span> References</h2>
<p>
Pointer and reference types capture the notion of a
memory address.
</p>
<ul>
<li>Not just alternate namings! They have very different properties.</li>
<li>Pointers are a numerical representation, and can be manipulated
as numbers to access <i>adjacent</i> memory locations.
<ul>
<li>Pointer arithmetic.</li>
<li>Note: adding <code>1</code> to a pointer does not shift by <code>1</code> bit;
it shifts by the size of the type being pointed to.</li>

</ul></li>
<li>A reference is a more abstract notion;
it cannot (or at least should not) be manipulated as a pointer can.</li>

</ul>

</section>
<section id="slide-orga926288">
<h3 id="orga926288"><span class="section-number-3">6.1</span> Referencing/dereferencing</h3>
<p>
In a language with reference types, we typically have
</p>
<ul>
<li>a <i>dereference</i> operator to access the value
stored at that reference
<ul>
<li>(written <code>*</code> in C and many C-like languages, and</li>
<li>written <code>!</code> in ML and languages descended from it),</li>

</ul></li>

</ul>
<p>
and we often have
</p>
<ul>
<li>a <i>reference</i> operator to obtain a reference to a stored value
<ul>
<li>(written <code>&amp;</code> in C and many C-like languages.)</li>

</ul></li>

</ul>

</section>
<section id="slide-orga1ef965">
<h3 id="orga1ef965"><span class="section-number-3">6.2</span> Garbage collection and dangling references</h3>
<p>
When discussing memory binding, we previously discussed
the concept of <i>garbage collection</i> and mentioned
another related problem:
</p>
<ul>
<li><i>dangling</i> or <i>wild</i> references.</li>

</ul>

<p>
A dangling or wild reference is a reference value
which refers to a memory location that has already been deallocated.
</p>
<ul>
<li>The contents of deallocated memory are usually not specified
by the language, so accessing it can result in undefined behaviour.</li>
<li>This <i>should</i> only occur if the language allows explicit deallocation
of memory (instead of only using implicit deallocation
through garbage collection.)</li>

</ul>

<p>
There are mechanisms to prevent against the use of dangling references.
</p>

</section>
<section id="slide-org6df9062">
<h3 id="org6df9062"><span class="section-number-3">6.3</span> Preventing the use of dangling references; tombstones</h3>
<p>
With the <i>tombstone</i> approach, every reference is in fact
a reference to a cell of memory called a <i>tombstone</i>,
which then refers to the value being stored in memory.
</p>
<ul>
<li>So there is an additional level of indirection.</li>
<li>When memory is deallocated, the tombstone is left,
but its reference is set to a null pointer.
<ul>
<li>So it can no longer be used; accessing a “nulled” tombstone
will result in an error.</li>

</ul></li>
<li>This is costly both in time (two dereferences are needed for each access)
and in space (the tombstone must remain indefinitely.)</li>

</ul>

</section>
<section id="slide-org2315107">
<h3 id="org2315107"><span class="section-number-3">6.4</span> Preventing the use of dangling references; locks and keys</h3>
<p>
With the <i>lock-and-keys</i> approach, a reference value is in fact
a pair of a special <i>key</i> value and the reference itself.
</p>
<ul>
<li>And referenced memory cells have allocated with them a
special <i>lock</i> value which matches those keys.</li>
<li>When memory is freed, the lock value for that cell is wiped.</li>
<li>So the keys of any remaining references are no longer valid.</li>
<li>This is also costly in time
<ul>
<li>(a comparison must be made between
the lock and the key at each access)</li>

</ul></li>
<li>and in space
<ul>
<li>(the lock and key values take space on every reference
and every memory cell)</li>

</ul></li>
<li>but not so much as tombstones.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org69d7730">
<h2 id="org69d7730"><span class="section-number-2">7</span> Further advanced topics</h2>
<p>
Depending upon time at the end of the course,
we may return to discuss more about types.
</p>
</section>
</section>
</div>
</div>
<script src="./reveal.js/dist/reveal.js"></script>
<script src="./reveal.js/plugin/markdown/markdown.js"></script>
<script src="./reveal.js/plugin/zoom/zoom.js"></script>
<script src="./reveal.js/plugin/notes/notes.js"></script>


<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
plugins: [RevealMarkdown,RevealZoom,RevealNotes],
width:1600, height:900, controlsLayout:'edges',
margin: 0.1, minScale:0.125, maxScale:5,
mouseWheel: true,
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
]
});
</script>
</body>
</html>
