#+Title: Introduction to Clojure
#+Author: Mark Armstrong
#+Description: An introduction to Clojure, a language in which
#+Description: programs themselves are written as data within the language.
#+SETUPFILE: ../../org-html-themes/setup/theme-readtheorg-local.setup

* LaTeX settings                                :noexport:

#+LaTeX_header: \usepackage{unicode-math}
#+LaTeX_header: \usepackage{unicode}

* Introduction
:PROPERTIES:
:CUSTOM_ID: Introduction
:END:

These notes were created for, and in some parts *during*,
the lecture on November 6th and the following tutorials.

* Motivation
:PROPERTIES:
:CUSTOM_ID: Motivation
:END:

:TODO:

* Getting Clojure

For a quick start with Clojure, you can use
[[https://repl.it/languages/clojure][repl.it]].

For instructions on installing Clojure,
see the Clojure [[https://clojure.org/guides/getting_started][getting started guide]].

Specific instructions on versions may come later,
once a Docker image is decided upon for Clojure.

* The syntax and (most of) the semantics of Clojure
:PROPERTIES:
:CUSTOM_ID: The-syntax-and-(most-of)-the-semantics-of-Clojure
:END:

The syntax of Lisps such as Clojure tend to be extremely minimal.
For today at least, we will work with a subset of the language
described by the following grammar, which is sufficient
for a fair amount of programming.
#+begin_src text
⟨expr⟩ ::= number
         | "nil"
         | ⟨list⟩
         | ⟨array⟩
         | symbol

⟨list⟩ ∷= "(" {⟨expr⟩} ")"

⟨array⟩ ∷= "[" {⟨expr⟩} "]"
#+end_src

For example, the following are all Clojure expressions.
#+begin_src clojure
2
-1

:symbols

()
'(1 2 3)
(quote (1 2 3))
'((1 2) (3 4))

[1 2 3]
[]

;; There are sets as well (unordered collections)
#{1 2 3}

;; Maps as well
{:key 1, "my key" :a_value}
#+end_src

#+RESULTS:
| 2                           |
| -1                          |
| :symbols                    |
| ()                          |
| (1 2 3)                     |
| (1 2 3)                     |
| ((1 2) (3 4))               |
| [1 2 3]                     |
| []                          |
| #{1 3 2}                    |
| {:key 1, "my key" :a_value} |

Clojure programs are written as lists,
with the head of the list being the /operator/ and
the tail of the list being the /operands/.
The (regular) semantics of Clojure expressions
can be described in just two lines;
to evaluate a list,
1. evaluate each element of the list, and then
2. apply the operands to the operator.
By default, Clojure does use call-by-value semantics.

For instance,
#+begin_src clojure
; (1 + 2) * max(3,4)
(* (+ 1 2)    ; (+ 1 2) evaluates to 3
   (max 4 3)  ; (max 4 3) evaluates to 4
   )          ; (* 3 4) evaluates to 12

(+ 1 2 3 4
   5 6 7 8)
(+ 1)
#+end_src

#+RESULTS:
| 12 |
| 36 |
|  1 |

* Special forms; the ~defn~, ~def~ and ~fn~ forms
:PROPERTIES:
:CUSTOM_ID: Special-forms;-the-~def~-and-~defn~-forms
:END:

When or if the evaluation rules of Clojure given above
prove too limiting, Clojure allows for “special forms”
(pieces of syntax handled differently by the compiler)
to implement constructs.

The first of these we will consider is the ~defn~ form,
which can be read “define function”.

For instance, here is code which defines two methods,
called ~square~ and ~sum_of_squares~,
and then calls ~sum_of_squares~ with arguments ~2~ and ~3~.
#+begin_src clojure :results value
(defn square [x] (* x x))

(defn sum-of-squares [x y]
  (+ (square x)
     (square y)))

(sum-of-squares 2 3)
#+end_src

#+RESULTS:
| #'user/square                     |
| #'user/sum-of-squares             |
| 13                                |
| class clojure.lang.ArityException |

Functions can be defined as having different arities.
#+begin_src clojure
; Define them by "brute force" 
(defn sum-of-squares
  ([x y]   (* (square x) (square y)))
  ([x y z] (* (square x) (square y) (square z))))

(sum-of-squares 2 3)
(sum-of-squares 2 3 4)

; Or define a "variadic" function which takes a list of arguments
(defn sum-of-squares [x & rest]
  (* (square x) ;; TODO
     ))

(sum-of-squares 2 3 4 5)
#+end_src

#+RESULTS:
| #'user/sum-of-squares              |
| 6                                  |
| 24                                 |
| #'user/sum-of-squares              |
| class java.lang.ClassCastException |

The ~defn~ form can be thought of
as the combination of the ~def~ and ~fn~ forms.
The ~def~ form defines named values.
#+begin_src clojure
(def my-favourite-number 16)
#+end_src

#+RESULTS:
: #'user/my-favourite-number

The ~fn~ form defines /anonymous/ functions.
#+begin_src clojure
((fn [x] (+ x 1)) my-favourite-number)
#+end_src

#+RESULTS:
: 17

* The ~quote~, ~'~
:PROPERTIES:
:CUSTOM_ID: The-~quote~,-~'~
:END:

Another special form is ~quote~, which is used
when you want to interpret a list as /data/ instead
of as a function invokation.
#+begin_src clojure
; call function +
(+ 1 2 3)

; create a list
(quote (+ 1 2 3))

; syntactic sugar
'(+ 1 2 3)
#+end_src

#+RESULTS:
| 6         |
| (+ 1 2 3) |
| (+ 1 2 3) |

* Conditional forms
:PROPERTIES:
:CUSTOM_ID: Conditional-forms
:END:

* ~do~, for sequential computation
:PROPERTIES:
:CUSTOM_ID: ~do~,-for-sequential-computation
:END:


* Side notes

** Partial application

Partial application would be implemented as
a function returning a function,
and invokation of such a function would look like
#+begin_src clojure
((f 3) 2)
#+end_src
