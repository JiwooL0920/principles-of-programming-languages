#+Title: An untyped λ-calculus, /UL/
#+Subtitle: Principles of Programming Languages
#+Author: Mark Armstrong
#+Date: Fall 2020
#+Description: Our first constructed language; a lambda calculus
#+Description: with no type checking (enforcement).
#+Options: toc:nil

* HTML settings                                 :noexport:

** Reveal settings

#+Reveal_root: ./reveal.js
#+Reveal_init_options: width:1600, height:900, controlsLayout:'edges',
#+Reveal_init_options: margin: 0.1, minScale:0.125, maxScale:5,
#+Reveal_init_options: mouseWheel: true
#+Reveal_extra_css: local.css

# #+HTML: <script src="https://cdnjs.cloudflare.com/ajax/libs/headjs/0.96/head.min.js"></script>

* LaTeX settings                                :noexport:

#+LaTeX_header: \usepackage{amsthm}
#+LaTeX_header: \theoremstyle{definition}
#+LaTeX_header: \newtheorem{definition}{Definition}[section]

#+LaTeX_header: \usepackage{unicode-math}
#+LaTeX_header: \usepackage{unicode}

* Setup                                         :noexport:

** Image creation post-processing

We need to prepend the images resulting from ~dot~ code blocks
with a LaTeX attribute to resize them, or else they run off the page.
This named code block for this task is taken from
[[https://orgmode.org/manual/Results-of-Evaluation.html][the Org manual]], augmented to allow for centering.
We should always provide ~*this*~ for the ~data~ argument.
as in ~:post attr_wrap(data=*this*)~,
and also always set ~:exports results :results drawer~.
If we don't put the results in the drawer, they will pile up
as we evaluate the code block.
#+NAME: attr_wrap
#+BEGIN_SRC sh :var data="" :var width="\\\\textwidth" :var center="t" :results output
  echo "#+ATTR_LATEX: :width $width :center $center"
  echo "$data"
#+END_SRC
* Preamble

** TODO Notable references

- Benjamin Pierce,
  “[[https://ebookcentral.proquest.com/lib/mcmu/detail.action?docID=3338823][Types and Programming Languages]]”
  - Chapter 5, The Untyped Lambda-Calculus

** TODO Table of contents

# The table of contents are added using org-reveal-manual-toc,
# and so must be updated upon changes or added last.
# Note that hidden headings are included, and so must be deleted!

#+HTML: <font size="-1">
#+begin_scriptsize
  - [[Preamble][Preamble]]
#+end_scriptsize
#+HTML: </font>

* Introduction

In this section we construct our first simple programming language,
an untyped λ-calculus (lambda calculus).

More specifically, we construct a λ-calculus
without (static) type checking (enforcement),
but including the natural numbers and booleans.

** What is the λ-calculus?

The λ-calculus is, put simply,
a notation for forming and applying functions.
- Because the function (procedure, method, subroutine) abstraction
  gives us a means of representing control flow,
  if we have a means of representing data,
  the λ-calculus is a Turing-complete model of computation.

** History

The (basic) λ-calculus as we know it was famously invented
by Alonzo Church in the 1920s.
- This was one culmination of a great deal of work by
  mathematicians investigating the foundations of mathematics.

As mentioned, the λ-calculus is a Turing-complete model of computation.
- Other models proposed around the same time include
  - the Turing machine itself (due to Alan Turing), and
  - the general recursive functions (due to Stephen Cole Kleene.)
- Hence the “Church” in the “Church-Turing thesis”.

The λ-calculus has since seen widespread use in the study and design
of programming languages.
- It is useful both as a simple programming language, and
- as a mathematical object about which statements can be proved.

** Descendents of the λ-calculus

Pure functional programming languages are clearly descended
from the λ-calculus; the λ-calculus embodies their model of computation.
- Additionally, it is common to have a “lambda” operator
  which allows definition of anonymous functions.

Imperative languages instead use a model of computation
based on the /Von-Neumann/ architecture,
- which matches our real-world computing devices!
  - Hence imperative languages are naturally lower-level;
    one level of abstraction closer to the real computer
    that functional languages, which must be translated
    to imperative code in order to run.
- This model of computation is a natural extension
  of the Turing machine, rather than the λ-calculus
  or recursive functions.
  
* The basics

In our discussion of abstractions, we mentioned
the abstraction of the function/method/procedure/subroutine.
- The functional abstraction provides a means
  to represent control flow.

In its pure version, every term in the λ-calculus
is a function.
- In order for such a system to be at all useful,
  it must of course support higher-order functions;
  functions may be applied to functions.
- Values such as booleans and natural numbers
  are /encoded/ (represented) by functions.

** The terms

The pure untyped λ-calculus has just three sort of terms;
- variables such as $x$, $y$, $z$,
- /λ-abstractions/, of the form $λ x → t$,
  - (it is also common to use $․$ in place of $→$;
    we prefer $→$ as it emphasises that these are functions)
  - where $x$ is a variable and $t$ is a λ-term, and
- applications of the form $t u$
  - where $t$ and $u$ are λ-terms.

** Informal meaning of terms

The meaning of each term is, informally:
- A λ-abstraction $λ x → t$ represents a function of one argument,
  which, when applied to a term $u$, substitutes
  all free occurrences of $x$ in $t$ with $u$.
- An application applies the term $u$ to the function (term) $t$.
- A variable on its own (a free variable) has no further meaning.
  - Variables are intended to be /bound/.
  - “Top-level” free variables have no meaning (on their own).
    - Until we construct a new term by λ-abstracting them.

** Variable binding; free and bound variables

Recall the notion of free and bound variables.
- A /variable binder/ is an operator which operates on
  some number of /variables/ as well as /terms/.
  - Examples include quantifiers
    such as $∀\_❙\_•\_$, $∃\_❙\_•\_$ and $∑\_❙\_•\_$,
    and substitution $\_[\_→\_]$.
- (For simplicity, let us assume below that variable binders
  act on a single variable and a single term.)
- Let $B\_•\_$ range over the set of variable binders in a language.
- An occurrence of a variable $x$ in a term $t$ that is /not/ in
  a subterm of the form $B x • u$ is called /free/.
- In a term $t$ with a subterm of the form $B x • u$,
  all free occurrences of the variable $x$ that occur within $u$
  are /bound/ by that instance of the binder $B$.
  - Note: instances of $x$ which are bound elsewhere are not bound
    by that $B$.

** Picturing variable bindings

# This diagram does not look correctly laid out in the source.
# But the arrows and the text do not line up this way
# in the generated diagram; they align somewhat nicely there.

For instance, in the language of predicate logic,
we can view the variables bound like so.
#+begin_src ditaa :file media/variable-binding.png :exports results :results drawer :post attr_wrap(data=*this*)
       /----+-----------+------+--------\
       |    |           |      |        |
       v    |           |      |        |
+-----------------------------------------------+
|∀ x ❙ P(x) • (∃ y ❙ Q(x,y) • R(x,y,z)) ∧ S(x,y)|
+-----------------------------------------------+
                  ^      |      | |       |
                  |      |      | |       |
                  \------+------/ |       |
                                  |       |
                            free -/       \- free
#+end_src

#+RESULTS:
:results:
#+ATTR_LATEX: :width \textwidth :center t
[[file:media/parsing-whole.png]]
:end:
    
** Representing functions with multiple arguments

You may have noticed that our method for constructing function
in the λ-calculus (the λ-abstraction)
only allows us to construct single-argument functions.
- That is, we do not have terms such as $λ(x,y) → t$.
- This may seem restrictive,
- but it turns out to be sufficient.
  And it keeps the language simpler theoretically.

** Currying

Rather than complicating our set of terms by admitting
functions of multiple arguments, we use the technique
of /currying/ functions.
- Consider a function $f : A × B → C$.
- We can substitute a new function $f′ : A → (B → C)$
  for $f$.
  - (By convention, function arrows associate to the right,
    so this is equivalent to $f : A → B → C$.)
  - So $f′$ is a function which takes an $A$ and
    /produces a function/ of type $B → C$.
    - We usually don't give this new function a name.
    - We can consider this new function as having a /fixed/ value
      for the $A$ argument that was provided.
    - (So we must be able to represent higher-order functions
      to use Currying.)

** Examples of λ-terms

#+begin_src text
λ x → x
#+end_src
is a familiar function; it is the /identity/ function.
We will use the name ~id~ to refer to this function.

#+begin_src text
λ x → λ y → x
#+end_src

#+begin_src text
λ x → λ y → y
#+end_src

* The formal syntax and semantics of /UL/

** A grammar for /UL/

#+begin_src text
⟨term⟩ ∷= var | λ var → ⟨term⟩ | ⟨term⟩ ⟨term⟩
#+end_src

In the case that we are restricted to ASCII characters,
we will write abstraction as
#+begin_src text
“lambda” var . ⟨term⟩
#+end_src

** The operational semantics of /UL/

The semantics of the λ-calculus is given by a /reduction strategy/;
- A reduction is a transformation from a term of the form
  - $(λ x → t₁) t₂$ to
  - $t₁[x ≔ t₂]$
    - (There are various syntactic representations of substitutions;
      we prefer to the substitution operation to come after the term
      where the substitution is carried out ($t₁$), and to use
      the “becomes” operator to imply free instance of $x$ become $t₂$. 
    - Pierce instead uses the form $[x ↦ t₂]t₁$, with the
      substitution operation coming before the term,
      and using the “maps to” operator instead of “becomes”.
    - You may also see forms such as $[x\t₁]$ or $[t₁/x]$.)

** Reduction strategies

:TODO:

* α-conversion, β-reduction and η-conversion

:TODO:

# η-conversion does not fit into the content here,
# but we should discuss it to tie in with Scala.

* Topics of theoretical interest

** The pure λ-calculus

:TODO:

** Nameless representation of terms

:TODO:
