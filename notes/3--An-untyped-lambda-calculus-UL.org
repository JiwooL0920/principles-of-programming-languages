#+Title: An untyped λ-calculus, /UL/
#+Subtitle: Principles of Programming Languages
#+Author: Mark Armstrong
#+Date: Fall 2020
#+Description: Our first constructed language; a lambda calculus
#+Description: with no type checking (enforcement).
#+Options: toc:nil

* HTML settings                                 :noexport:

** Reveal settings

#+Reveal_root: ./reveal.js
#+Reveal_init_options: width:1600, height:900, controlsLayout:'edges',
#+Reveal_init_options: margin: 0.1, minScale:0.125, maxScale:5,
#+Reveal_init_options: mouseWheel: true
#+Reveal_extra_css: local.css

# #+HTML: <script src="https://cdnjs.cloudflare.com/ajax/libs/headjs/0.96/head.min.js"></script>

* LaTeX settings                                :noexport:

#+LaTeX_header: \usepackage{amsthm}
#+LaTeX_header: \theoremstyle{definition}
#+LaTeX_header: \newtheorem{definition}{Definition}[section]

#+LaTeX_header: \usepackage{unicode-math}
#+LaTeX_header: \usepackage{unicode}

* Preamble

** TODO Notable references

- Benjamin Pierce,
  “[[https://ebookcentral.proquest.com/lib/mcmu/detail.action?docID=3338823][Types and Programming Languages]]”
  - Chapter 5, The Untyped Lambda-Calculus

** TODO Table of contents

# The table of contents are added using org-reveal-manual-toc,
# and so must be updated upon changes or added last.
# Note that hidden headings are included, and so must be deleted!

#+HTML: <font size="-1">
#+begin_scriptsize
  - [[Preamble][Preamble]]
#+end_scriptsize
#+HTML: </font>

* Introduction

In this section we construct our first simple programming language,
an untyped λ-calculus (lambda calculus).

More specifically, we construct a λ-calculus
without (static) type checking (enforcement),
but including the natural numbers and booleans.

** What is the λ-calculus?

The λ-calculus is, put simply,
a notation for forming and applying functions.
- Because the function (procedure, method, subroutine) abstraction
  gives us a means of representing control flow,
  if we have a means of representing data,
  the λ-calculus is a Turing-complete model of computation.

** History

The (basic) λ-calculus as we know it was famously invented
by Alonzo Church in the 1920s.
- This was one culmination of a great deal of work by
  mathematicians investigating the foundations of mathematics.

As mentioned, the λ-calculus is a Turing-complete model of computation.
- Other models proposed around the same time include
  - the Turing machine itself (due to Alan Turing), and
  - the general recursive functions (due to Stephen Cole Kleene.)
- Hence the “Church” in the “Church-Turing thesis”.

The λ-calculus has since seen widespread use in the study and design
of programming languages.
- It is useful both as a simple programming language, and
- as a mathematical object about which statements can be proved.

** Descendents of the λ-calculus

:TODO:

# Very recently, a great many imperative languages
# are adopting functional aspects.

* The basics

In our discussion of abstractions, we mentioned
the abstraction of the function/method/procedure/subroutine.
- The functional abstraction provides a means
  to represent control flow.

In its pure version, every term in the λ-calculus
is a function.
- In order for such a system to be at all useful,
  it must of course support higher-order functions;
  functions may be applied to functions.
- Values such as booleans and natural numbers
  are /encoded/ (represented) by functions.

** The terms

The pure untyped λ-calculus has just three sort of terms;
- variables such as $x$, $y$, $z$,
- /λ-abstractions/, of the form $λ x ∙ t$,
  - where $x$ is a variable and $t$ is a λ-term, and
- applications of the form $t u$
  - where $t$ and $u$ are λ-terms.

The meaning of each term is, informally:
- A λ-abstraction $λ x ∙ t$ represents a function of one argument,
  which, when applied to a term $u$, substitutes
  all occurrences of $x$ with $u$.
- An application applies the term $u$ to the function (term) $t$.
- A variable on its own (a free variable) has no further meaning.
  - Variables are intended to be /bound/.

** Variable binding

:TODO:

* The formal syntax and semantics of /UL/

** A grammar for /UL/

#+begin_src text
⟨term⟩ ∷= var | λ var • ⟨term⟩ | ⟨term⟩ ⟨term⟩
#+end_src

In the case that we are restricted to ASCII characters,
we will write abstraction as
#+begin_src text
“lambda” var . ⟨term⟩
#+end_src

* α-conversion, β-reduction and η-conversion

:TODO:

# η-conversion does not fit into the content here,
# but we should discuss it to tie in with Scala.

* Topics of theoretical interest

** The pure λ-calculus

:TODO:

** Nameless representation of terms

:TODO:
