#+Title: An untyped λ-calculus, /UL/
#+Subtitle: Principles of Programming Languages
#+Author: Mark Armstrong
#+Date: Fall 2020
#+Description: Our first constructed language; a lambda calculus
#+Description: with no type checking (enforcement).
#+Options: toc:nil

* HTML settings                                 :noexport:

** Reveal settings

#+Reveal_root: ./reveal.js
#+Reveal_init_options: width:1600, height:900, controlsLayout:'edges',
#+Reveal_init_options: margin: 0.1, minScale:0.125, maxScale:5,
#+Reveal_init_options: mouseWheel: true
#+Reveal_extra_css: local.css

# #+HTML: <script src="https://cdnjs.cloudflare.com/ajax/libs/headjs/0.96/head.min.js"></script>

* LaTeX settings                                :noexport:

#+LaTeX_header: \usepackage{amsthm}
#+LaTeX_header: \theoremstyle{definition}
#+LaTeX_header: \newtheorem{definition}{Definition}[section]

#+LaTeX_header: \usepackage{unicode-math}
#+LaTeX_header: \usepackage{unicode}

* Setup                                         :noexport:

** Image creation post-processing

We need to prepend the images resulting from ~dot~ code blocks
with a LaTeX attribute to resize them, or else they run off the page.
This named code block for this task is taken from
[[https://orgmode.org/manual/Results-of-Evaluation.html][the Org manual]], augmented to allow for centering.
We should always provide ~*this*~ for the ~data~ argument.
as in ~:post attr_wrap(data=*this*)~,
and also always set ~:exports results :results drawer~.
If we don't put the results in the drawer, they will pile up
as we evaluate the code block.
#+NAME: attr_wrap
#+BEGIN_SRC sh :var data="" :var width="\\\\textwidth" :var center="t" :results output
echo "#+ATTR_LATEX: :width $width :center $center"
echo "$data"
#+END_SRC

* Preamble
:PROPERTIES:
:CUSTOM_ID: Preamble
:END:

** TODO Notable references
:PROPERTIES:
:CUSTOM_ID: Notable-references
:END:

- Benjamin Pierce,
  “[[https://ebookcentral.proquest.com/lib/mcmu/detail.action?docID=3338823][Types and Programming Languages]]”
  - Chapter 5, The Untyped Lambda-Calculus

** TODO Table of contents
:PROPERTIES:
:CUSTOM_ID: Table-of-contents
:END:

# The table of contents are added using org-reveal-manual-toc,
# and so must be updated upon changes or added last.
# Note that hidden headings are included, and so must be deleted!

#+HTML: <font size="-1">
#+begin_scriptsize
  - [[Preamble][Preamble]]
#+end_scriptsize
#+HTML: </font>

* Introduction
:PROPERTIES:
:CUSTOM_ID: Introduction
:END:

In this section we construct our first simple programming language,
an untyped λ-calculus (lambda calculus).

More specifically, we construct a λ-calculus
without (static) type checking (enforcement),
but including the natural numbers and booleans.

** What is the λ-calculus?
:PROPERTIES:
:CUSTOM_ID: What-is-the-λ-calculus?
:END:

The λ-calculus is, put simply,
a notation for forming and applying functions.
- Because the function (procedure, method, subroutine) abstraction
  gives us a means of representing control flow,
  if we have a means of representing data,
  the λ-calculus is a Turing-complete model of computation.

** History
:PROPERTIES:
:CUSTOM_ID: History
:END:

The (basic) λ-calculus as we know it was famously invented
by Alonzo Church in the 1920s.
- This was one culmination of a great deal of work by
  mathematicians investigating the foundations of mathematics.

As mentioned, the λ-calculus is a Turing-complete model of computation.
- Other models proposed around the same time include
  - the Turing machine itself (due to Alan Turing), and
  - the general recursive functions (due to Stephen Cole Kleene.)
- Hence the “Church” in the “Church-Turing thesis”.

The λ-calculus has since seen widespread use in the study and design
of programming languages.
- It is useful both as a simple programming language, and
- as a mathematical object about which statements can be proved.

** Descendents of the λ-calculus
:PROPERTIES:
:CUSTOM_ID: Descendents-of-the-λ-calculus
:END:

Pure functional programming languages are clearly descended
from the λ-calculus; the λ-calculus embodies their model of computation.
- Additionally, it is common to have a “lambda” operator
  which allows definition of anonymous functions.

Imperative languages instead use a model of computation
based on the /Von-Neumann/ architecture,
- which matches our real-world computing devices!
  - Hence imperative languages are naturally lower-level;
    one level of abstraction closer to the real computer
    that functional languages, which must be translated
    to imperative code in order to run.
- This model of computation is a natural extension
  of the Turing machine, rather than the λ-calculus
  or recursive functions.
  
* The basics
:PROPERTIES:
:CUSTOM_ID: The-basics
:END:

In our discussion of abstractions, we mentioned
the abstraction of the function/method/procedure/subroutine.
- The functional abstraction provides a means
  to represent control flow.

In its pure version, every term in the λ-calculus
is a function.
- In order for such a system to be at all useful,
  it must of course support higher-order functions;
  functions may be applied to functions.
- Values such as booleans and natural numbers
  are /encoded/ (represented) by functions.

** The terms
:PROPERTIES:
:CUSTOM_ID: The-terms
:END:

The pure untyped λ-calculus has just three sort of terms;
- variables such as $x$, $y$, $z$,
- /λ-abstractions/, of the form $λ x → t$,
  - (it is also common to use $․$ in place of $→$;
    we prefer $→$ as it emphasises that these are functions)
  - where $x$ is a variable and $t$ is a λ-term, and
- applications of the form $t u$
  - where $t$ and $u$ are λ-terms.

** Informal meaning of terms
:PROPERTIES:
:CUSTOM_ID: Informal-meaning-of-terms
:END:

The meaning of each term is, informally:
- A λ-abstraction $λ x → t$ represents a function of one argument,
  which, when applied to a term $u$, substitutes
  all free occurrences of $x$ in $t$ with $u$.
- An application applies the term $u$ to the function (term) $t$.
- A variable on its own (a free variable) has no further meaning.
  - Variables are intended to be /bound/.
  - “Top-level” free variables have no meaning (on their own).
    - Until we construct a new term by λ-abstracting them.

** Variable binding; free and bound variables
:PROPERTIES:
:CUSTOM_ID: Variable-binding;-free-and-bound-variables
:END:

Recall the notion of free and bound variables.
- A /variable binder/ is an operator which operates on
  some number of /variables/ as well as /terms/.
  - Examples include quantifiers
    such as $∀\_❙\_•\_$, $∃\_❙\_•\_$ and $∑\_❙\_•\_$,
    and substitution $\_[\_→\_]$.
- (For simplicity, let us assume below that variable binders
  act on a single variable and a single term.)
- Let $B\_•\_$ range over the set of variable binders in a language.
- An occurrence of a variable $x$ in a term $t$ that is /not/ in
  a subterm of the form $B x • u$ is called /free/.
- In a term $t$ with a subterm of the form $B x • u$,
  all free occurrences of the variable $x$ that occur within $u$
  are /bound/ by that instance of the binder $B$.
  - Note: instances of $x$ which are bound elsewhere are not bound
    by that $B$.

** Picturing variable bindings
:PROPERTIES:
:CUSTOM_ID: Picturing-variable-bindings
:END:

# This diagram does not look correctly laid out in the source.
# But the arrows and the text do not line up this way
# in the generated diagram; they align somewhat nicely there.

For instance, in the language of predicate logic,
we can view the variables bound like so.
#+begin_src ditaa :file media/variable-binding.png :exports results :results drawer :post attr_wrap(data=*this*)
       /----+-----------+------+--------\
       |    |           |      |        |
       v    |           |      |        |
+-----------------------------------------------+
|∀ x ❙ P(x) • (∃ y ❙ Q(x,y) • R(x,y,z)) ∧ S(x,y)|
+-----------------------------------------------+
                  ^      |      | |       |
                  |      |      | |       |
                  \------+------/ |       |
                                  |       |
                            free -/       \- free
#+end_src

#+RESULTS:
:results:
#+ATTR_LATEX: :width \textwidth :center t
[[file:media/parsing-whole.png]]
:end:
    
** Representing functions with multiple arguments
:PROPERTIES:
:CUSTOM_ID: Representing-functions-with-multiple-arguments
:END:

You may have noticed that our method for constructing function
in the λ-calculus (the λ-abstraction)
only allows us to construct single-argument functions.
- That is, we do not have terms such as $λ(x,y) → t$.
- This may seem restrictive,
- but it turns out to be sufficient.
  And it keeps the language simpler theoretically.

** Currying
:PROPERTIES:
:CUSTOM_ID: Currying
:END:

Rather than complicating our set of terms by admitting
functions of multiple arguments, we use the technique
of /currying/ functions.
- Consider a function $f : A × B → C$.
- We can substitute a new function $f′ : A → (B → C)$
  for $f$.
  - (By convention, function arrows associate to the right,
    so this is equivalent to $f : A → B → C$.)
  - So $f′$ is a function which takes an $A$ and
    /produces a function/ of type $B → C$.
    - We usually don't give this new function a name.
    - We can consider this new function as having a /fixed/ value
      for the $A$ argument that was provided.
    - (So we must be able to represent higher-order functions
      to use Currying.)

** Examples of λ-terms
:PROPERTIES:
:CUSTOM_ID: Examples-of-λ-terms
:END:

#+begin_src text
λ x → x
#+end_src
is a familiar function; it is the /identity/ function.
We will use the name ~id~ to refer to this function.

#+begin_src text
λ x → λ y → x
#+end_src

#+begin_src text
λ x → λ y → y
#+end_src

* The formal syntax and semantics of /UL/
:PROPERTIES:
:CUSTOM_ID: The-formal-syntax-and-semantics-of-/UL/
:END:


** Preamble                                    :ignore:

We now discuss the formal semantics of the untyped λ-calculus;
that is, we
- give a grammar for its syntax, and
- define operational semantics for the language.

** A grammar for /UL/
:PROPERTIES:
:CUSTOM_ID: A-grammar-for-/UL/
:END:

#+begin_src text
⟨term⟩ ∷= var | λ var → ⟨term⟩ | ⟨term⟩ ⟨term⟩
#+end_src

In the case that we are restricted to ASCII characters,
we will write abstraction as
#+begin_src text
“lambda” var . ⟨term⟩
#+end_src

** The operational semantics of /UL/
:PROPERTIES:
:CUSTOM_ID: The-operational-semantics-of-/UL/
:END:

A term of the form $(λ x → t₁) t₂$ is called a /redex/,
meaning /reducible expression/.

The semantics of the λ-calculus is given by a /reduction strategy/
(/β/-reduction strategy);
- A reduction (β-reduction) transforms a subterm of the form
  - $(λ x → t₁) t₂$ (a redex) to
  - $t₁[x ≔ t₂]$.
    - (There are various syntactic representations of substitutions;
      we prefer to the substitution operation to come after the term
      where the substitution is carried out ($t₁$), and to use
      the “becomes” operator to imply free instance of $x$ become $t₂$. 
    - Pierce instead uses the form $[x ↦ t₂]t₁$, with the
      substitution operation coming before the term,
      and using the “maps to” operator instead of “becomes”.
    - You may also see forms such as $[x\backslash t₁]$ or $[t₁/x]$.)
      
** Reduction strategies
:PROPERTIES:
:CUSTOM_ID: Reduction-strategies
:END:

Given an arbitrary term, there may be several subterms which are redexes,
- so we have a choice of what subterm to reduce.
A reduction strategy limits our choice of which redex to reduce.

Several strategies have been studied. We discuss just four of them.
- full β-reduction,
- normal order,
- call by name, and
- call by value.
We only give a full formal treatment to call-by-value.
  
The last two you may know as names of parameter passing methods
from (practical) programming languages.
- There is a direct correspondance between reduction strategies
  and parameter passing methods.

** Reduction strategies: full β-reduction and normal order
:PROPERTIES:
:CUSTOM_ID: Reduction-strategies:-full-β-reduction
:END:

The /full β-reduction/ strategy is, essentially, to have no
strategy at all.

Under full β-reduction, and redex can be reduced at any point.

The /normal order/ strategy enforces that the
leftmost, outermost redex is always reduced first.

** Reduction strategies: call by name and call by value
:PROPERTIES:
:CUSTOM_ID: Reduction-strategies:-call-by-name
:END:

The /call by name/ strategy builds on the normal order strategy
- by mandating that no reductions take place inside abstractions.
- So “arguments cannot be evaluated before being applied”.
  
The /call by value/ strategy also builds on the normal order strategy,
- by mandating that a redex is reduced only when its right hand side
  - (the “argument”)
  cannot be reduced (is a value.)

** A formal description of call by value semantics

Let us use the convention that variable names involving
- ~t~ represent arbitrary λ-terms, whereas variable names involving
- ~v~ represent irreducible λ-terms (values).

Then we may give a formal description of call-by-value semantics
using inference rules.
#+begin_src text
   t₁ ⟶ t₁′
–––––––––––––––– Applicationˡ
t₁ t₂ ⟶ t₁′ t₂


   
   t₂ ⟶ t₂′
–––––––––––––––– Applicationʳ
v₁ t₂ ⟶ v₁ t₂′


   
–––––––––––––––––––––––– Application to abstraction
(λ x → t) v ⟶ t[x ≔ v]
#+end_src

** α-conversion and η-conversion
:PROPERTIES:
:CUSTOM_ID: α-conversion,-β-reduction-and-η-conversion
:END:

:TODO:

# η-conversion does not fit into the content here,
# but we should discuss it to tie in with Scala.


β-reduction gives us one way to equate terms;
- two terms “have the same value” if they both reduce to the same
  value (irreducible term.)

:TODO:

** Normalisation

A λ-term is said to be in /normal form/ if it cannot be reduced.

:TODO:

* λ-encodings
:PROPERTIES:
:CUSTOM_ID: λ-encodings
:END:

** Preamble                                    :ignore:

As mentioned previously, in the pure λ-calculus,
every term is a function.
- There are no basic types of data.

So, we must have a way of representing any data as
a function.
- We call these Church encodings.

We will show how to do this for
- booleans,
- pairs, and
- natural numbers,
and give some “combinators” which operate on these kinds of data.

** Church booleans

We define the following terms to represent boolean values.
- ~tru~ represents truth, and
- ~fls~ represents false.
#+begin_src text
tru = λ t → λ f → t
fls = λ t → λ f → f
#+end_src

These choices are /somewhat/ arbitrary.
- We could choose any two distinct λ-terms.
- But they are not really arbitrary;
  these two terms embody the idea that a boolean value
  is a “choice” between two options.
  - ~tru~, when given two arguments, “chooses” the first.
  - ~fls~, when given two arguments, “chooses” the second.

** Defining ~if-then-else~ using Church booleans

Since the Church encoded booleans already “perform” a choice,
defining an “~if-then-else~” construct
using them is quite straightforward.
#+begin_src text
test = λ l → λ m → λ n → l m n
#+end_src
The intention is that
- the first argument is a Church boolean,
- the second is the “~then~” branch, and
- the third is the “~else~” branch. 

Notice that ~test b v w~ simply reduces to ~b v w~;
- the boolean ~b~ really “does the work”
  of choosing between ~v~ and ~w~.

** Pairs

:TODO:

** Church numerals

:TODO:

** Addition and multiplication

:TODO:

* Enriching the calculus

* 
